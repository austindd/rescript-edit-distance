// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");

var assert_codePointAt_alwaysSome = "Assert: 'codePointAt(word)' is always 'Some(char)'";

var ErrorMsg = {
  assert_codePointAt_alwaysSome: assert_codePointAt_alwaysSome
};

function min3(a, b, c) {
  if (a <= b && a <= c) {
    return a;
  } else if (b <= c) {
    return b;
  } else {
    return c;
  }
}

function handleEmptyStrings(a, b) {
  if (a === "") {
    if (b === "") {
      return 0;
    } else {
      return b.length;
    }
  } else if (b === "") {
    return a.length;
  } else {
    return ;
  }
}

function levenshtein(word1, word2) {
  var result = handleEmptyStrings(word1, word2);
  if (result !== undefined) {
    return result;
  }
  var m = word1.length;
  var n = word2.length;
  var cur = [];
  cur.length = m + 1 | 0;
  cur[0] = 0;
  for(var x = 1; x <= m; ++x){
    cur[x] = x;
  }
  for(var j = 1; j <= n; ++j){
    var pre = cur[0];
    cur[0] = j;
    for(var i = 1; i <= m; ++i){
      var temp = cur[i];
      var optChar1 = word1.codePointAt(i - 1 | 0);
      var optChar2 = word2.codePointAt(j - 1 | 0);
      if (optChar1 !== undefined && optChar2 !== undefined) {
        if (optChar1 === optChar2) {
          cur[i] = pre;
        } else {
          var a = cur[i] + 1 | 0;
          var b = cur[i - 1 | 0] + 1 | 0;
          var c = pre + 1 | 0;
          cur[i] = min3(a, b, c);
        }
        pre = temp;
      } else {
        Pervasives.failwith(assert_codePointAt_alwaysSome);
      }
    }
  }
  return cur[m];
}

function damerauLevenshtein(maxLength, _first, _second) {
  var maxL = maxLength !== undefined ? maxLength : 255;
  var _currentRow = Caml_array.caml_make_vect(maxL + 1 | 0, 0);
  var _previousRow = Caml_array.caml_make_vect(maxL + 1 | 0, 0);
  var _transpositionRow = Caml_array.caml_make_vect(maxL + 1 | 0, 0);
  var first = _first;
  var second = _second;
  var firstLength = first.length;
  var secondLength = second.length;
  if (firstLength === 0) {
    return secondLength;
  }
  if (secondLength === 0) {
    return firstLength;
  }
  if (firstLength > secondLength) {
    var tmp = first;
    first = second;
    second = tmp;
    firstLength = secondLength;
    secondLength = second.length;
  }
  if (maxL < 0) {
    maxL = secondLength;
  }
  if ((secondLength - firstLength | 0) > maxL) {
    return maxL + 1 | 0;
  }
  if (firstLength > _currentRow.length) {
    var tempLength = firstLength + 1 | 0;
    _currentRow = Belt_Array.make(tempLength, 0);
    _previousRow = Belt_Array.make(tempLength, 0);
    _transpositionRow = Belt_Array.make(tempLength, 0);
  }
  for(var i = 0; i <= firstLength; ++i){
    Caml_array.set(_previousRow, i, i);
  }
  var lastSecondCh = 0;
  for(var i$1 = 1; i$1 <= secondLength; ++i$1){
    var secondCh = second.codePointAt(i$1 - 1 | 0);
    if (secondCh !== undefined) {
      Caml_array.set(_currentRow, 0, i$1);
      var from_ = Caml_primitive.caml_int_max((i$1 - maxL | 0) - 1 | 0, 1);
      var to_ = Caml_primitive.caml_int_min((i$1 + maxL | 0) + 1 | 0, firstLength);
      var lastFirstCh = 0;
      for(var j = from_; j <= to_; ++j){
        var firstCh = first.codePointAt(j - 1 | 0);
        if (firstCh !== undefined) {
          var cost = firstCh === secondCh ? 0 : 1;
          var value = Caml_primitive.caml_int_min(Caml_primitive.caml_int_min(Caml_array.get(_currentRow, j - 1 | 0) + 1 | 0, Caml_array.get(_previousRow, j) + 1 | 0), Caml_array.get(_previousRow, j - 1 | 0) + cost | 0);
          if (firstCh === lastSecondCh && secondCh === lastFirstCh) {
            value = Caml_primitive.caml_int_min(value, Caml_array.get(_transpositionRow, j - 2 | 0) + cost | 0);
            Caml_array.set(_currentRow, j, value);
            lastFirstCh = firstCh;
          }
          
        } else {
          throw {
                RE_EXN_ID: "Match_failure",
                _1: [
                  "EditDistance.res",
                  130,
                  14
                ],
                Error: new Error()
              };
        }
      }
      lastSecondCh = secondCh;
      var tempRow = _transpositionRow;
      _transpositionRow = _previousRow;
      _previousRow = _currentRow;
      _currentRow = tempRow;
    } else {
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "EditDistance.res",
              123,
              12
            ],
            Error: new Error()
          };
    }
  }
  return Caml_array.get(_previousRow, firstLength);
}

function damerauLevenshtein2(maxLength, _first, _second) {
  var l1 = _first.length;
  var l2 = _second.length;
  var match = l1 > l2 ? [
      _second,
      l2,
      _first,
      l1
    ] : [
      _first,
      l1,
      _second,
      l2
    ];
  var secondLength = match[3];
  var firstLength = match[1];
  if (firstLength === 0) {
    return secondLength;
  }
  if (secondLength === 0) {
    return firstLength;
  }
  var second = match[2];
  var first = match[0];
  var maxL = maxLength !== undefined ? (
      maxLength < 0 ? secondLength : maxLength
    ) : 255;
  if ((secondLength - firstLength | 0) > maxL) {
    return maxL + 1 | 0;
  }
  var match$1 = firstLength > (maxL + 1 | 0) ? [
      {
        contents: Belt_Array.make(firstLength + 1 | 0, 0)
      },
      {
        contents: Belt_Array.make(firstLength + 1 | 0, 0)
      },
      {
        contents: Belt_Array.make(firstLength + 1 | 0, 0)
      }
    ] : [
      {
        contents: Belt_Array.make(maxL + 1 | 0, 0)
      },
      {
        contents: Belt_Array.make(maxL + 1 | 0, 0)
      },
      {
        contents: Belt_Array.make(maxL + 1 | 0, 0)
      }
    ];
  var _transpositionRow = match$1[2];
  var _previousRow = match$1[1];
  var _currentRow = match$1[0];
  for(var i = 0; i <= firstLength; ++i){
    _previousRow.contents[i] = i;
  }
  var lastSecondCh = 0;
  for(var i$1 = 1; i$1 <= secondLength; ++i$1){
    var secondCh = second.codePointAt(i$1 - 1 | 0);
    if (secondCh !== undefined) {
      _currentRow.contents[0] = i$1;
      var from_ = Caml_primitive.caml_int_max((i$1 - maxL | 0) - 1 | 0, 1);
      var to_ = Caml_primitive.caml_int_min((i$1 + maxL | 0) + 1 | 0, firstLength);
      var lastFirstCh = 0;
      for(var j = from_; j <= to_; ++j){
        var firstCh = first.codePointAt(j - 1 | 0);
        if (firstCh !== undefined) {
          var cost = firstCh === secondCh ? 0 : 1;
          var temp = min3(_currentRow.contents[j - 1 | 0] + 1 | 0, _previousRow.contents[j] + 1 | 0, _previousRow.contents[j - 1 | 0] + cost | 0);
          var value = firstCh === lastSecondCh && secondCh === lastFirstCh ? Caml_primitive.caml_int_min(temp, _transpositionRow.contents[j - 2 | 0] + cost | 0) : temp;
          _currentRow.contents[j] = value;
          lastFirstCh = firstCh;
        } else {
          throw {
                RE_EXN_ID: "Match_failure",
                _1: [
                  "EditDistance.res",
                  211,
                  14
                ],
                Error: new Error()
              };
        }
      }
      lastSecondCh = secondCh;
      var tempRow = _transpositionRow.contents;
      _transpositionRow.contents = _previousRow.contents;
      _previousRow.contents = _currentRow.contents;
      _currentRow.contents = tempRow;
    } else {
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "EditDistance.res",
              204,
              12
            ],
            Error: new Error()
          };
    }
  }
  return _previousRow.contents[firstLength];
}

function damerauLevenshtein3(maxLength, _first, _second) {
  var l1 = _first.length;
  var l2 = _second.length;
  var match = l1 > l2 ? [
      _second,
      l2,
      _first,
      l1
    ] : [
      _first,
      l1,
      _second,
      l2
    ];
  var secondLength = match[3];
  var firstLength = match[1];
  if (firstLength === 0) {
    return secondLength;
  }
  if (secondLength === 0) {
    return firstLength;
  }
  var second = match[2];
  var first = match[0];
  var maxL = maxLength !== undefined ? (
      maxLength < 0 ? secondLength : maxLength
    ) : 255;
  if ((secondLength - firstLength | 0) > maxL) {
    return maxL + 1 | 0;
  }
  var currentRow = [];
  var previousRow = [];
  var transpositionRow = [];
  var correctLength = firstLength > (maxL + 1 | 0) ? firstLength + 1 | 0 : maxL + 1 | 0;
  currentRow.length = correctLength;
  previousRow.length = correctLength;
  transpositionRow.length = correctLength;
  for(var i = 0; i <= correctLength; ++i){
    currentRow[i] = 0;
    previousRow[i] = 0;
    transpositionRow[i] = 0;
  }
  for(var i$1 = 0; i$1 <= firstLength; ++i$1){
    previousRow[i$1] = i$1;
  }
  var _i = 1;
  var _currentRow = currentRow;
  var _previousRow = previousRow;
  var _transpositionRow = transpositionRow;
  var _lastSecondCh = 0;
  while(true) {
    var lastSecondCh = _lastSecondCh;
    var transpositionRow$1 = _transpositionRow;
    var previousRow$1 = _previousRow;
    var currentRow$1 = _currentRow;
    var i$2 = _i;
    var secondCh = second.codePointAt(i$2 - 1 | 0);
    if (secondCh === undefined) {
      return Pervasives.failwith(assert_codePointAt_alwaysSome);
    }
    currentRow$1[0] = i$2;
    var __a = (i$2 - maxL | 0) - 1 | 0;
    var from_ = __a > 1 ? __a : 1;
    var __b = (i$2 + maxL | 0) + 1 | 0;
    var to_ = __b < firstLength ? __b : firstLength;
    var lastFirstCh = 0;
    for(var j = from_; j <= to_; ++j){
      var firstCh = first.codePointAt(j - 1 | 0);
      if (firstCh !== undefined) {
        var cost = firstCh === secondCh ? 0 : 1;
        var temp1 = min3(currentRow$1[j - 1 | 0] + 1 | 0, previousRow$1[j] + 1 | 0, previousRow$1[j - 1 | 0] + cost | 0);
        var value;
        if (firstCh === lastSecondCh && secondCh === lastFirstCh) {
          var temp2 = transpositionRow$1[j - 2 | 0] + cost | 0;
          value = temp1 < temp2 ? temp1 : temp2;
        } else {
          value = temp1;
        }
        currentRow$1[j] = value;
        lastFirstCh = firstCh;
      } else {
        Pervasives.failwith(assert_codePointAt_alwaysSome);
      }
    }
    if (i$2 >= secondLength) {
      return currentRow$1[firstLength];
    }
    _lastSecondCh = secondCh;
    _transpositionRow = previousRow$1;
    _previousRow = currentRow$1;
    _currentRow = transpositionRow$1;
    _i = i$2 + 1 | 0;
    continue ;
  };
}

exports.ErrorMsg = ErrorMsg;
exports.min3 = min3;
exports.handleEmptyStrings = handleEmptyStrings;
exports.levenshtein = levenshtein;
exports.damerauLevenshtein = damerauLevenshtein;
exports.damerauLevenshtein2 = damerauLevenshtein2;
exports.damerauLevenshtein3 = damerauLevenshtein3;
/* No side effect */
